/*
Copyright(c) 2017 Checkmarx

Author: João Pena Gil (Jack64)

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
OR OTHER DEALINGS IN THE SOFTWARE.
*/
using System;
using System.Collections.Generic;
using System.Diagnostics.Eventing.Reader;
using System.IO;
using System.Security.Cryptography;
using System.Text;
using System.Threading;

namespace jobCryptor
{
    /// <summary>
    /// 
    /// </summary>
    class EncryptedFileFinder
    {

        /// <summary>
        /// tdsDecode function reverse engineered from jobCrypter
        /// Performs the 3DES decryption of encrypted files
        /// </summary>
        /// <param name="text"></param>
        /// <param name="password"></param>
        /// <returns>decrypted string</returns>
        public static string tdsDecode(string text, string password)
        {
            TripleDESCryptoServiceProvider tripleDESCryptoServiceProvider = new TripleDESCryptoServiceProvider();
            MD5CryptoServiceProvider mD5CryptoServiceProvider = new MD5CryptoServiceProvider();
            tripleDESCryptoServiceProvider.Key = mD5CryptoServiceProvider.ComputeHash(Encoding.ASCII.GetBytes(password));
            tripleDESCryptoServiceProvider.Mode = CipherMode.ECB;
            ICryptoTransform cryptoTransform = tripleDESCryptoServiceProvider.CreateDecryptor();
            byte[] array = Convert.FromBase64String(text);
            return Encoding.ASCII.GetString(cryptoTransform.TransformFinalBlock(array, 0, array.Length));
        }

        /// <summary>
        /// Asserts whether the CSS file was generated by the ransomware
        /// </summary>
        /// <param name="filename"></param>
        /// <returns></returns>
        public static bool isEncryptedFile(string filename)
        {
            string ransom_msg = "Bonjour, nous somme des";
            try
            {
                FileStream stream = new FileStream(filename,FileMode.Open);
                byte[] bytes = new byte[ransom_msg.Length+1];
                int offset = 0;
                while (offset < ransom_msg.Length + 1 )
                {
                    int read = stream.Read(bytes, offset, ransom_msg.Length - offset + 1);
                    if (read == 0)
                        throw new System.IO.EndOfStreamException();
                    offset += read;
                }

                string text = System.Text.Encoding.UTF8.GetString(bytes);
                if (text.Contains(ransom_msg))
                {
                    return true;
                }
            }
            catch (Exception) { };
            return false;
        }

        /// <summary>
        /// Decode_File(string x,string password) reverse engineered from jobCrypter
        /// This parses and decrypts the encrypted .CSS file with the ransom message
        /// and file data (Modified to test valid decryption of PNGs)
        /// </summary>
        /// <param name="filename"></param>
        /// <param name="password"></param>
        public static void Decode_File(string filename, string password)
        {
            checked
            {
                try
                {
                    string text = File.ReadAllText(filename);
                    string[] array = text.Split(new char[] { ';' });

                    int num = 0;
                    foreach (string text2 in array)
                    {
                        if (num == 0)
                        {
                            num = 1;
                        }
                        else if (num == 1)
                        {
                            text = text2;
                        }
                    }

                    string s = tdsDecode(text, password);
                    byte[] toBytes = Convert.FromBase64String(s);


                    //PNG magic header: 89 50 4E 47
                    if (toBytes[0] == 137 && toBytes[1] == 80 && toBytes[2] == 78 && toBytes[3] == 71)
                    {
                        Console.WriteLine("[+] Success!");
                        Console.WriteLine("[+] Password: {0}", password);
                        Console.Read();
                        Environment.Exit(0);
                    }

                    return;
                }
                catch (Exception) { }
            }
        }

        /// <summary>
        /// Iterate over the filesystem (reverse engineered from jobCrypter)
        /// </summary>
        /// <param name="dossier"></param>
        /// <param name="lastTime"></param>
        public static void ChercherFichiers(DirectoryInfo dossier, ref DateTime lastTime, ref FileInfo targetPNG)
        {
            DateTime localmax = lastTime;
            checked
            {
                try
                {
                    FileInfo[] files = dossier.GetFiles("*.*");
                    FileInfo[] array = files;
                    foreach (FileInfo fileInfo in array)
                    {
                        if (fileInfo.FullName.EndsWith(".css") && isEncryptedFile(fileInfo.FullName))
                        {
                            //If the file is a PNG, save its location to use as a decryption target
                            if (fileInfo.FullName.EndsWith(".png.css"))
                            {
                                
                                if (!File.Exists(targetPNG.FullName)){
                                    targetPNG = fileInfo;
                                } else {
                                    if (fileInfo.Length < targetPNG.Length)
                                    {
                                        targetPNG = fileInfo;
                                    }
                                }
                            }
                            DateTime thisTime = File.GetCreationTime(fileInfo.FullName);
                            if (thisTime < lastTime)
                            {
                                lastTime = thisTime;
                            }
                        }
                    }
                    DirectoryInfo[] directories = dossier.GetDirectories();
                    foreach (DirectoryInfo dossier2 in directories)
                    {
                        DateTime thisTime = lastTime;
                        ChercherFichiers(dossier2, ref thisTime,ref targetPNG);
                        if (thisTime < lastTime)
                        {
                            lastTime = thisTime;
                        }
                    }
                }
                catch (Exception) { }
            }

        }

        /// <summary>
        /// Returns the first encrypted file's timestamp (reverse engineered from jobCrypter and modified)
        /// </summary>
        /// <returns></returns>
        public static DateTime getFirstEncryptedFile(ref FileInfo targetPNG)
        {
            DriveInfo[] drives = DriveInfo.GetDrives();
            DateTime timestamp = DateTime.MaxValue;
            checked
            {
                for (int i = 0; i < drives.Length; i++)
                {
                    DriveInfo driveInfo = drives[i];
                    if (driveInfo.IsReady)
                    {
                        DateTime thisTimestamp = timestamp;
                        ChercherFichiers(new DirectoryInfo(driveInfo.RootDirectory.ToString()), ref thisTimestamp, ref targetPNG);
                        if (thisTimestamp < timestamp)
                        {
                            timestamp = thisTimestamp;
                        }
                    }
                }
            }

            return timestamp;
        }

        /// <summary>
        /// Gets the timestamp from the last reboot prior to encryption
        /// of the first file from the Windows Event Log
        /// </summary>
        /// <param name="firstEncryptedFile"></param>
        /// <returns></returns>
        public static DateTime getLastReboot(DateTime firstEncryptedFile)
        {
            string eventID = "6005"; // “The event log service was started.” This is synonymous to system startup. 
            string LogSource = "System"; 
            string sQuery = $"*[System/EventID={eventID}]";

            var elQuery = new EventLogQuery(LogSource, PathType.LogName, sQuery);
            var elReader = new EventLogReader(elQuery);
            DateTime lastReboot = default(DateTime);
            List<EventRecord> eventList = new List<EventRecord>();

            for (EventRecord eventInstance = elReader.ReadEvent();
                null != eventInstance; eventInstance = elReader.ReadEvent())
            {
                DateTime thisReboot = (DateTime)eventInstance.TimeCreated;

                //Make sure we get timestamp of the last reboot prior to the ransomware attack
                if (lastReboot < thisReboot && thisReboot < firstEncryptedFile)
                {
                    lastReboot = thisReboot;
                }
            }

            if (lastReboot == default(DateTime))
            {
                Console.Write("[-] Unable to retrieve last boot time from Windows Event Log. This will severely impact password crack time.");
            }

            return lastReboot;

        }

        /// <summary>
        /// Retrieve CPU count
        /// </summary>
        /// <returns></returns>
        public static int getCPUCount()
        {
            int coreCount = 0;
            foreach (var item in new System.Management.ManagementObjectSearcher("Select * from Win32_Processor").Get())
            {
                coreCount += int.Parse(item["NumberOfCores"].ToString());
            }
            return coreCount;
        }

        /// <summary>
        /// Set up multi-threaded password-cracking routine
        /// </summary>
        /// <param name="args"></param>
        /// <param name="timestamp"></param>
        /// <param name="lastReboot"></param>
        public static void CalculatePassword(string[] args, DateTime timestamp, DateTime lastReboot, FileInfo targetPNG)
        {
            double approxTickCount = 0;

            //If the automatic calculation of the encryption timestamp fails,
            //ask the user, else, calculate approxTickCount automatically.
            if (lastReboot > timestamp)
            {
                approxTickCount = getUserTimeEstimation();

            }
            else {

                //Calculate approximate Environment.TickCount at password generation time
                approxTickCount = (timestamp - lastReboot).Ticks / 10000;
            }

            runWorkers(approxTickCount,targetPNG);

            //Key was not found within the automatically defined interval
            //so now we brute-force with user information
            approxTickCount = getUserTimeEstimation();
            runWorkers(approxTickCount, targetPNG);

            Console.WriteLine("[-] Key not found.");
            Environment.Exit(2);
        }


        /// <summary>
        /// Run multi-threaded password-cracking routine
        /// </summary>
        /// <param name="approxTickCount"></param>
        /// <param name="minTicks"></param>
        /// <param name="maxTicks"></param>
        /// <param name="searchspace"></param>
        private static void runWorkers(double approxTickCount, FileInfo targetPNG)
        {
            //Set the upper/lower bound of the search space
            int minTicks = (int)(approxTickCount - 40000);
            int maxTicks = (int)(approxTickCount + 40000);
            int searchspace = (int)(maxTicks - minTicks);

            //Use a PNG file that is shipped with Windows 10 that is encrypted by jobCrypter
            string filename = targetPNG.FullName;

            //this could also work with a user-provided jobCrypter-encrypted PNG,
            //should the default not be present in the infected machine
            while (!File.Exists(filename))
            {
                Console.WriteLine("[-] {0} was not found, please enter the path for an encrypted PNG:", filename);
                filename = Console.ReadLine();
            }

            int num_threads = getCPUCount();
            int rem = 0;
            int i = 0;
            int start = minTicks;

            Console.WriteLine("[*] Cracking password...");

            //Start the password-cracking procedure
            Thread[] ta = new Thread[num_threads];
            while (i < num_threads)
            {
                int off = (int)Math.Floor((searchspace / (float)num_threads) + (rem > 0 ? num_threads - (searchspace % num_threads) : 0));
                PasswordCalculatorSlice a = new PasswordCalculatorSlice(i, filename, start, off, num_threads);
                Thread oThread = new Thread(new ThreadStart(a.runSlice));
                ta[i] = oThread;
                oThread.Start();
                start += off;
                i++;
            }
            foreach (Thread t in ta)
            {
                t.Join();
            }
        }

        /// <summary>
        /// If the automatic calculation of the encryption timestamp fails,
        /// ask the user for estimate number of minutes from boot to infection
        /// </summary>
        private static double getUserTimeEstimation()
        {
            Console.WriteLine("[-] Unable to retrieve password.\n"+
                "The password used for encrypted depends on the number of minutes elapsed from the machine boot until infection.\n"+
                "Please provide an estimate of minutes elapsed from boot to infection (or press enter if you are unsure)");
            int userTime = -1;
            while (userTime < 0)
            {
                try
                {
                    string time = Console.ReadLine();
                    userTime = Int32.Parse(time);
                }
                catch (Exception) {
                    userTime = 720; //12 hours
                    Console.WriteLine("[!] Proceeding with default time value: {0}min", userTime);  
                };
            }
            return userTime * 60 * 1000;
        }
    }
}
